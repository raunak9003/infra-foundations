now basically all templates are pretty simple

the main stuff on which we should focus in ingress class and ingress class params.

now what are ingress class??

ğŸ§  Step 1: Think of the IngressClass as a â€œlabelâ€ or â€œcategoryâ€

The IngressClass is just a definition â€”
like a named configuration that says:

â€œIf someone uses this class name (alb),
the AWS Load Balancer Controller will handle it.â€

But it does nothing on its own.

Itâ€™s like saying:

â€œIâ€™ve defined a rule for using a public ALB.â€
But until you create an Ingress that uses that rule, nothing happens.

âš™ï¸ Step 2: You control which apps get Load Balancers

For example:

You have an IngressClass defined:

```yaml
apiVersion: networking.k8s.io/v1
kind: IngressClass
metadata:
  name: alb-public
spec:
  controller: ingress.k8s.aws/alb

```

Now two apps:

ğŸŸ¢ App 1: Frontend (public)
```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: frontend-ingress
spec:
  ingressClassName: alb-public
  rules:
    - host: shop.skyflow.com
      http:
        paths:
          - path: /
            backend:
              service:
                name: frontend-service
                port:
                  number: 80

```
âœ… This one will get a Load Balancer, because it uses that alb-public class.
```yaml
ğŸ”´ App 2: Payment (internal)
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: payment-ingress
spec:
  rules:
    - host: payment.skyflow.internal
      http:
        paths:
          - path: /
            backend:
              service:
                name: payment-service
                port:
                  number: 8080

```
âš ï¸ Here, thereâ€™s no ingressClassName.
Kubernetes wonâ€™t assign it to any controller,
so nothing happens â€” no Load Balancer created.


now what about ingress class params??


IngressClassParams is an AWS-specific custom resource (CRD).
It defines how the controller should behave when creating a load balancer for this class.

Think of it like the â€œsettings fileâ€ or â€œblueprintâ€ for that IngressClass.


ğŸ§± Step 4: Example 1 â€” Public IngressClassParams

Letâ€™s say you want a public ALB that routes Internet traffic:
```
apiVersion: elbv2.k8s.aws/v1beta1
kind: IngressClassParams
metadata:
  name: alb-public
spec:
  scheme: internet-facing
  ipAddressType: ipv4
  tags:
    environment: prod
    type: public
```

Then your IngressClass points to it:
```
apiVersion: networking.k8s.io/v1
kind: IngressClass
metadata:
  name: alb-public
spec:
  controller: ingress.k8s.aws/alb
  parameters:
    apiGroup: elbv2.k8s.aws
    kind: IngressClassParams
    name: alb-public
```

âœ… Result:
Whenever you create an Ingress with ingressClassName: alb-public,
AWS Load Balancer Controller will create an internet-facing ALB.

ğŸ§± Step 5: Example 2 â€” Internal IngressClassParams

Now for private/internal services:
```
apiVersion: elbv2.k8s.aws/v1beta1
kind: IngressClassParams
metadata:
  name: alb-internal
spec:
  scheme: internal
  namespaceSelector:
    matchLabels:
      access: private
  tags:
    environment: prod
    type: internal

```
Then link it in the IngressClass:
```
apiVersion: networking.k8s.io/v1
kind: IngressClass
metadata:
  name: alb-internal
spec:
  controller: ingress.k8s.aws/alb
  parameters:
    apiGroup: elbv2.k8s.aws
    kind: IngressClassParams
    name: alb-internal

```
âœ… Result:

ALBs created for this class are private (internal).

Only namespaces with label access: private can use it.

This prevents devs from accidentally exposing internal services (like payment).
